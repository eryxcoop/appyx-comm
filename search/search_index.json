{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Appyx","text":""},{"location":"#appyx-comm","title":"Appyx-Comm","text":"<p>A library to help you to communicate with Appyx, but also if your are not using it! Now your requests are simpler and responses can be handled easily.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>In order to contribute please ensure the following:</p> <ul> <li>All tests are passing locally with <code>npm test</code>.</li> <li>If adding a new feature you also add documentation.</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>appyx-comm requires node to be installed on your system.</p>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<p>Test are created using vitest. To run them you must first install the dependencies and then run:</p> <pre><code>$ npm install\n$ npm test\n</code></pre>"},{"location":"contributing/#testing-package-locally","title":"Testing package locally","text":"<p>To test the package locally you can use the following command:</p> <pre><code>$ npm link\n</code></pre> <p>You can also test a branch of the package by using the following command (replace <code>branch-name</code> with the name of the branch):</p> <pre><code>$ npm install \"https://github.com/eryxcoop/appyx-comm.git#branch-name\" --save\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>appyx-comm uses sphinx for building documentation, and all documentation is stored in the <code>docs/</code> directory at the root of the repository.</p> <p>To make changes to the documentation you must first initialize the workspace with poetry (inside docs folder):</p> <pre><code>$ poetry install\n</code></pre> <p>After making changes, build the documentation and open the resulting HTML in your browser to make sure your changes have rendered correctly:</p> <pre><code>$ poetry run make html\n$ poetry run python -m webbrowser \"file://$PWD/html/index.html\"\n</code></pre>"},{"location":"contributing/#publishing","title":"Publishing","text":"<p>Before publishing a new release, ensure that the version number in <code>package.json</code> is correct.</p>"},{"location":"contributing/#automatic-release","title":"Automatic release","text":"<p>A release can be created automatically by creating a release in github. name of the release must follow the pattern <code>@eryxcoop/appyx-comm-X.Y.Z</code> where <code>X.Y.Z</code> is the version number. The release will be created automatically by the CI/CD pipeline.</p> <p>Please clarify changes in the release description.</p>"},{"location":"contributing/#manual-release","title":"Manual release","text":"<p>If release creation fails to publish new version, you can create it manually. First ensure your NPM_TOKEN is set by running the following command:</p> <pre><code>$ npm config set //registry.npmjs.org/:_authToken={$NPM_TOKEN}\n</code></pre> <p>Then you are ready to publish the release:</p> <pre><code>$ npm publish\n</code></pre> <p>Now your release is available on NPM.</p>"},{"location":"examples/","title":"Examples","text":"<p>We add some common uses of the appyx-comm package that may come in handy.</p>"},{"location":"examples/#authentication","title":"Authentication","text":"<p>Imagine having an access token and a refresh token. Given a specific time, the access token will expire and we will need to refresh it using the refresh token. You may not want to be checking the expiration time of the access token every time you make a request. You can a generic response handler, that will try to authenticate the user if the response status is 401.</p> <pre><code>const generalErrorHandler = ApiResponseHandler.for(\n    AuthenticationErrorResponse,\n    async () =&gt; {\n        // We are not authenticated, let's try to refresh the access token\n        const refreshToken = this._refreshToken();\n        try {\n            const refreshResponse = await this._refreshAccessToken(refreshToken);\n            await this._updateSession(refreshResponse.accessToken(), refreshResponse.refreshToken());\n        } catch (_) {\n            // We couldn't refresh the access token, let's log out\n            return await this._application.logOut();\n        }\n        // We refreshed the access token, let's retry the request\n        return await request.retry();\n    },\n);\n</code></pre> <p>Now we can create our ApiClient using this generalErrorHandler. Every time we receive a 401 response, the generalErrorHandler will try to refresh the access token. In case of failure, it will log out the user.</p> <pre><code>const apiClient = new ApiClient(generalErrorHandler);\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installing","title":"Installing","text":"<pre><code>$ npm install @eryxcoop/appyx-comm\n</code></pre>"},{"location":"lib/","title":"User Guide","text":""},{"location":"lib/#requesters","title":"Requesters","text":""},{"location":"lib/#remoterequester","title":"RemoteRequester","text":"<p><code>RemoteRequester</code> is class that represents a requester. It is used to make requests to the api. You can create your own requester by extending this class. In case of an error connecting with the sever, an <code>ConnectivityErrorResponse</code> is returned.</p> <pre><code>const authorizationManager = new AppAuthorizationManager(this);\nconst remoteRequester = new RemoteRequester(remoteApiUrl, authorizationManager);\n</code></pre>"},{"location":"lib/#fakerequester","title":"FakeRequester","text":"<p><code>FakeRequester</code> can be used if you are testing your application without having a server running on the other side. Fake will respond the <code>defaultResponse</code> you indicate in your expected response of the endpoint you are calling. <code>FakeRequester</code> will also mock the waiting time of the request. If you don't indicate a waiting time, it will wait 2500 ms.</p> <pre><code>const fakeRequester = new FakeRequester({waitingTime: 2500});\n</code></pre> <p>If you don't want to use the default response message, you can override it by passing the response you want to return.</p> <pre><code>const fakeRequester = new FakeRequester();\nfakeRequester.addResponseFor(new ExampleEndpoint(), ExampleSuccessfulResponse);\n</code></pre>"},{"location":"lib/#endpoints","title":"Endpoints","text":"<p>When you create and <code>Endpoint</code> you are defining where the request should be made, what type of request is it and what kind of responses should you expect. Your ApiClient will be able to execute the endpoint you created. For example, you can create an endpoint like this:</p> <pre><code>class ExampleEndpoint extends Endpoint {\n  url() {\n    return \"example_url\";\n  }\n\n  ownResponses() {\n    return [GetExampleResponse];\n  }\n\n  method() {\n    return this.constructor.getMethod();\n  }\n\n  needsAuthorization() {\n    return true;\n  }\n}\n\n\n// Now you can use it like this\nconst endpointToExample = new ExampleEndpoint();\nconst response = await client.callEndpoint(endpointToExample);\n</code></pre> <p>Now from v1.0.6 you can use the <code>Endpoint</code> class to create your own endpoints. This way you can avoid creating multiple endpoints files and stop using heritage.</p> <pre><code>const getAuthenticatedEndpoint = Endpoint.newGet(\n  {\n    url: \"my/examplet/endpoint/path\",\n    ownResponses: [GetExampleResponse]\n  }\n);\n</code></pre> <p>By default endpoint will require authorization, but you can specify otherwise.</p> <pre><code>const getNotAuthenticatedEndpoint = Endpoint.newGet(\n  {\n    url: \"my/examplet/endpoint/path\",\n    ownResponses: [GetExampleResponse],\n    needsAuthorization: false\n  }\n);\n</code></pre> <p>Supported methods are: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>.</p>"},{"location":"lib/#responses","title":"Responses","text":"<p>Every time you make a call to the api, you will (usually) receive a response. Response is here for you to represent that response. That way you can easily tell your endpoint what kind of responses it should expect. You can use already created responses in the library such as  <code>SuccessfulApiResponse</code> or you can create your own to make use of its full potential and ask your response for specific information</p> <p>Here is an example of a response:}</p> <pre><code>// We extend from successful api response because we are representing the successful response of our call.\nclass ExampleSuccessfulResponse extends SuccessfulApiResponse {\n  static defaultResponse() {\n    return {\n      object: {\n        example: {\n          value: 1,\n        },\n      },\n      errors: [],\n    };\n  }\n\n  get exampleValue() {\n    return this.content().example.value;\n  }\n}\n</code></pre>"},{"location":"lib/#response-handler","title":"Response Handler","text":""},{"location":"lib/#basic-use","title":"Basic use","text":"<p>Response handlers are used to handle responses received from api requests. Every time you make a call you can indicate the way every expected response should be handled. For example, you can indicate that every successful response should be handled by running a function. Note that <code>ResponseHandler</code> is an immutable object, so every time you indicate the way responses should be handled, you are actually overriding the default response handler.</p> <pre><code>const customResponseHandler = ApiResponseHandler.for(\n  SuccessfulApiResponse,\n  (response, request) =&gt; {\n    doSomething();\n  },\n);\n\n// doSomething() will be called if exampleEndpoint returns a SuccessfulApiResponse\nawait client.exampleEndpoint(customResponseHandler);\n</code></pre> <p>Sometimes you want to handle an specific response always in the same way. For example, you may want to handle every 401 response by authenticating the user again. To do this you have to indicate all your general responses handlers in the client constructor. For example:</p> <pre><code>const generalResponsesHandler = ApiResponseHandler.for(\n  AuthenticationErrorResponse,\n  (response, request) =&gt; {\n    return authenticateUserAgain();\n  },\n);\nconst client = new ExampleApiClient(requester, generalResponsesHandler);\n</code></pre>"},{"location":"lib/#multiple-response-handler","title":"Multiple response handler","text":"<p>In order to have multiple responses to consider, you can clarify them all with the <code>handler</code> method. Remember that <code>ApiResponseHandler</code> is an unmutable object, so everytime a response is add it will return a new <code>ApiResponseHandler</code> object. For example:</p> <pre><code>let responsesHandler = new ApiResponseHandler();\nresponsesHandler = responseHandler.handles(\n  SuccessfulApiResponse,\n  (response, request) =&gt; {\n    return doSomething();\n  },\n);\nresponsesHandler = responseHandler.handles(\n  AuthenticationErrorResponse,\n  (response, request) =&gt; {\n    return authenticateUserAgain();\n  },\n);\nconst client = new ExampleApiClient(requester, responsesHandler);\n</code></pre> <p>Now you may be wondering, what happens if I want to handle a specific response in a different way? Well, you can already do that! every time you indicate the way responses should be handled, you are actually overriding the default response handler. So, if you want to handle a specific response in a different way, just override the default response handler again.</p>"},{"location":"lib/#successful-and-error-responses","title":"Successful and error responses","text":"<p>Sometimes you may want to have only two different cases to handle, successful responses and error responses. You can do that by:</p> <pre><code>let responsesHandler = new ApiResponseHandler();\nresponsesHandler = responseHandler\n  .handlesSuccess((response, request) =&gt; {\n      return doSomething();\n    },\n  ).handlesError((response, request) =&gt; {\n      return authenticateUserAgain();\n    },\n  );\nconst client = new ExampleApiClient(requester, responsesHandler);\n</code></pre>"},{"location":"lib/#apiclient","title":"ApiClient","text":"<p>Finally, you can create your own ApiClient using <code>ApiClient</code> class. This class is the one that will be used to make the requests to the api.</p> <p>We add a small example of a complete case of use:</p> <pre><code>class MyApiClient {\n\n  // We recommend to create you own api client to sum up all the calls you will make to the api\n\n  constructor(requester) {\n    this._apiClient = new ApiClient(requester);\n  }\n\n  registerNewUser(email, responseHandler) {\n    const endpoint = new RegisterUserEndpoint();\n    return this._apiClient.callEndpoint(endpoint, {email}, responseHandler);\n  }\n}\n\n// We create remote requester\nconst authorizationManager = new AppAuthorizationManager(this);\nconst remoteRequester = new RemoteRequester(remoteApiUrl, authorizationManager);\n\n// We create the client\nconst endpointToExample = new MyApiClient(remoteRequester);\n\n// We create responses handler for registering a new user\nconst responseHandler = new ApiResponseHandler({\n  handlesError: (error) =&gt; {\n    console.log(error);\n  },\n  handlesSuccess: (response) =&gt; {\n    console.log(\"success!!\")\n  }\n});\n\n// We register a new user\nclient.registerNewUser(\"delfi@brea.com\", responseHandler);\n</code></pre>"}]}